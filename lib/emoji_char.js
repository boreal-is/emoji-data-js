// Generated by CoffeeScript 2.5.1
var EmojiChar, punycode;

punycode = require('punycode');

// EmojiChar represents a single Emoji character and its associated metadata.

// ## Properties

// * `name` - The standardized name used in the Unicode specification to
//   represent this emoji character.
// * `unified` - The primary unified codepoint ID for the emoji.
// * `variations` - A list of all variant codepoints that may also represent this
//   emoji.
// * `short_name` - The canonical "short name" or keyword used in many systems to
//   refer to this emoji. Often surrounded by `:colons:` in systems like GitHub
//   & Campfire.
// * `short_names` - A full list of possible keywords for the emoji.
// * `text` - An alternate textual representation of the emoji, for example a
//   smiley face emoji may be represented with an ASCII alternative. Most emoji
//   do not have a text alternative. This is typically used when building an
//   automatic translation from typed emoticons.

// It also contains a few helper functions to deal with this data type.

EmojiChar = class EmojiChar {
  // @param blob [Object] the JSON blob entry from emoji-data
  // @return [EmojiChar]
  constructor(blob) {
    var k, v;
    for (k in blob) {
      v = blob[k];
      this[k] = v;
    }
    if (this.variations == null) {
      // source file doesnt include blank variations field if none exist,
      // for our sake, lets add that here.
      this.variations = [];
    }
  }

  // Is the `EmojiChar` represented by a doublebyte codepoint in Unicode?

  // @return [Boolean]
  is_doublebyte() {
    return this.unified.indexOf('-') !== -1;
  }

  // Does the `EmojiChar` have an alternate Unicode variant encoding?

  // @return [Boolean] true when the EmojiChar has at least one variant encoding
  has_variants() {
    return this.variations.length > 0;
  }

  // Returns the most likely variant-encoding codepoint ID for an `EmojiChar`.

  // For now we only know of one possible variant encoding for certain
  // characters, but there could be others in the future.

  // This is typically used to force Emoji rendering for characters that could
  // be represented in standard font glyphs on certain operating systems.

  // The resulting encoded string will be two codepoints, or three codepoints
  // for doublebyte Emoji characters.

  // @return [String, null]
  //   The most likely variant-encoding codepoint ID.
  //   If there is no variant-encoding for a character, returns null.
  variant() {
    if (!(this.variations.length > 0)) {
      return null;
    }
    return this.variations[0];
  }

  // Renders a UCS-2 string representation of the glyph for writing to screen.

  // If you want to specify whether or not to use variant encoding, pass an
  // options hash such as:

  //     foo.char({variant_encoding: true})

  // By default this will use the variant encoding if it exists.

  // @param options [Object] the encoding options
  // @option options [Boolean] variant_encoding true if you want to render with
  //   variant encoding.

  // @return [String] the emoji character rendered to a UCS-2 string
  render({variant_encoding} = {
      variant_encoding: true
    }) {
    var target;
    target = (function() {
      switch (false) {
        case !(this.has_variants() && variant_encoding):
          return this.variant();
        default:
          return this.unified;
      }
    }).call(this);
    return EmojiChar._unified_to_char(target);
  }

  // Returns a list of all possible UTF-8 string renderings of an `EmojiChar`.

  // E.g., normal, with variant selectors, etc. This is useful if you want to
  // have all possible values to match against when searching for the emoji in
  // a string representation.

  // @return [Array<String>] all possible UCS-2 string renderings
  chars() {
    var i, id, len, ref, results;
    ref = [this.unified].concat(this.variations);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      id = ref[i];
      results.push(EmojiChar._unified_to_char(id));
    }
    return results;
  }

  // @see #render()
  // @return [String]
  toString() {
    return this.render();
  }

  // Convert a unified codepoint ID to the UCS-2 string representation.

  // @param [String] uid the unified codepoint ID for an emoji
  // @return [String] UCS-2 string representation of the emoji glyph
  // @private
  static _unified_to_char(uid) {
    var cp, cps;
    cps = (function() {
      var i, len, ref, results;
      ref = uid.split('-');
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        cp = ref[i];
        results.push(parseInt(cp, 16));
      }
      return results;
    })();
    return punycode.ucs2.encode(cps);
  }

};

module.exports = EmojiChar;
