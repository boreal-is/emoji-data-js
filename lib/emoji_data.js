// Generated by CoffeeScript 2.5.1
var EmojiChar, EmojiData, punycode;

EmojiChar = require('./emoji_char');

punycode = require('punycode');

EmojiData = (function() {
  var EMOJICHAR_KEYWORD_MAP, EMOJICHAR_UNIFIED_MAP, EMOJI_CHARS, EMOJI_MAP, FBS_REGEXP, char_blob, ec, i, j, k, keyword, l, len, len1, len2, len3, ref, ref1, variant;

  class EmojiData {
    // Returns a list of all known Emoji characters as `EmojiChar` objects.

    // @return [Array<EmojiChar>] a list of all known `EmojiChar`.
    static all() {
      return EMOJI_CHARS;
    }

    // Returns a list of all `EmojiChar` that are represented with doublebyte
    // encoding.

    // @return [Array<EmojiChar>] a list of all doublebyte `EmojiChar`.
    static all_doublebyte() {
      var len4, n, results;
      results = [];
      for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
        ec = EMOJI_CHARS[n];
        if (ec.is_doublebyte()) {
          results.push(ec);
        }
      }
      return results;
    }

    // Returns a list of all `EmojiChar` that have at least one variant encoding.

    // @return [Array<EmojiChar>] a list of all `EmojiChar` with variant encoding.
    static all_with_variants() {
      var len4, n, results;
      results = [];
      for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
        ec = EMOJI_CHARS[n];
        if (ec.has_variants()) {
          results.push(ec);
        }
      }
      return results;
    }

    // Returns a list of all known Emoji characters rendered as UCS-2 strings.

    // By default, the default rendering options for this library will be used.
    // However, if you pass an option hash with `include_variants: true` then all
    // possible renderings of a single glyph will be included, meaning that:

    // 1. You will have "duplicate" emojis in your list.
    // 2. This list is now suitable for exhaustably matching against in a search.

    // @option options [Boolean] :include_variants whether or not to include all
    //   possible encoding variants in the list

    // @return [Array<String>] all Emoji characters rendered as UTF-8 strings
    static chars(options = {
        include_variants: false
      }) {
      var extra, norms;
      norms = (function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
          ec = EMOJI_CHARS[n];
          results.push(ec.render({
            variant_encoding: false
          }));
        }
        return results;
      })();
      extra = (function() {
        var len4, n, ref2, results;
        ref2 = this.all_with_variants();
        results = [];
        for (n = 0, len4 = ref2.length; n < len4; n++) {
          ec = ref2[n];
          results.push(ec.render({
            variant_encoding: true
          }));
        }
        return results;
      }).call(this);
      if (options.include_variants) {
        return norms.concat(extra);
      }
      return norms;
    }

    // Returns a list of all known codepoints representing Emoji characters.

    // @option options [Boolean] :include_variants whether or not to include all
    //   possible encoding variants in the list
    // @return [Array<String>] all codepoints represented as unified ID strings
    static codepoints(options = {
        include_variants: false
      }) {
      var extra, norms;
      norms = (function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
          ec = EMOJI_CHARS[n];
          results.push(ec.unified);
        }
        return results;
      })();
      extra = (function() {
        var len4, n, ref2, results;
        ref2 = this.all_with_variants();
        results = [];
        for (n = 0, len4 = ref2.length; n < len4; n++) {
          ec = ref2[n];
          results.push(ec.variant());
        }
        return results;
      }).call(this);
      if (options.include_variants) {
        return norms.concat(extra);
      }
      return norms;
    }

    // Convert a native UCS-2 string glyph to its unified codepoint ID.

    // This is a conversion operation, not a match, so it may produce unexpected
    // results with different types of values.

    // @param char [String] a single rendered emoji glyph encoded as a UCS-2 string
    // @return [String] the unified ID

    // @example
    //   > EmojiData.unified_to_char("1F47E");
    //   'ðŸ‘¾'
    static char_to_unified(char) {
      var cp, cps, hexes;
      cps = punycode.ucs2.decode(char);
      hexes = (function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = cps.length; n < len4; n++) {
          cp = cps[n];
          results.push(cp.toString(16).padStart(4, "0"));
        }
        return results;
      })();
      return hexes.join("-").toUpperCase();
    }

    // Convert a unified codepoint ID directly to its UCS-2 string representation.

    // @param uid [String] the unified codepoint ID for an emoji
    // @return [String] UCS-2 string rendering of the emoji character

    // @example
    //   > EmojiData.char_to_unified("ðŸ‘¾");
    //   '1F47E'
    static unified_to_char(uid) {
      return EmojiChar._unified_to_char(uid);
    }

    // Finds any `EmojiChar` that contains given string in its official name.

    // @param name [String]
    // @return [Array<EmojiChar>]
    static find_by_name(name) {
      var len4, n, results, target;
      target = name.toUpperCase();
      results = [];
      for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
        ec = EMOJI_CHARS[n];
        if (ec.name.indexOf(target) !== -1) {
          results.push(ec);
        }
      }
      return results;
    }

    // Find all `EmojiChar` that match string in any of their associated short
    // name keywords.

    // @param short_name [String]
    // @return [Array<EmojiChar>]
    static find_by_short_name(short_name) {
      var len4, n, results, target;
      target = short_name.toLowerCase();
      results = [];
      for (n = 0, len4 = EMOJI_CHARS.length; n < len4; n++) {
        ec = EMOJI_CHARS[n];
        if (ec.short_names.some(function(sn) {
          return sn.indexOf(target) !== -1;
        })) {
          results.push(ec);
        }
      }
      return results;
    }

    // Finds a specific `EmojiChar` based on the unified codepoint ID.

    // Must be exact match.

    // @param short_name [String]
    // @return [EmojiChar]
    static from_short_name(short_name) {
      return EMOJICHAR_KEYWORD_MAP[short_name.toLowerCase()];
    }

    // Finds a specific `EmojiChar` based on its unified codepoint ID.

    // @param uid [String] the unified codepoint ID for an emoji
    // @return [EmojiChar]
    static from_unified(uid) {
      return EMOJICHAR_UNIFIED_MAP[uid.toUpperCase()];
    }

    // Scans a string for all encoded emoji characters contained within.

    // @param str [String] the target string to search
    // @return [Array<EmojiChar>] all emoji characters contained within the target
    //    string, in the order they appeared.
    static scan(str) {
      var id, len4, m, matches, n, results;
      // since JS doesnt seem to have the equivalent of .scan we do some hacky shit
      // http://stackoverflow.com/questions/13895373/

      // reset regexp pointer (really js? sigh)
      FBS_REGEXP.lastIndex = 0;
      // keep executing regex until it returns no more results
      matches = [];
      while ((m = FBS_REGEXP.exec(str))) {
        matches.push(m[0]);
      }
      results = [];
      for (n = 0, len4 = matches.length; n < len4; n++) {
        id = matches[n];
        // map matched chars to EmojiChar objects
        results.push(this.from_unified(this.char_to_unified(id)));
      }
      return results;
    }

  };

  EMOJI_MAP = require('../vendor/emoji-data/emoji.json');

  EMOJI_CHARS = (function() {
    var i, len, results;
    results = [];
    for (i = 0, len = EMOJI_MAP.length; i < len; i++) {
      char_blob = EMOJI_MAP[i];
      results.push(new EmojiChar(char_blob));
    }
    return results;
  })();

  // construct hashmap for fast precached lookups for `.from_unified`
  EMOJICHAR_UNIFIED_MAP = {};

  for (i = 0, len = EMOJI_CHARS.length; i < len; i++) {
    ec = EMOJI_CHARS[i];
    EMOJICHAR_UNIFIED_MAP[ec.unified] = ec;
    ref = ec.variations;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      variant = ref[j];
      EMOJICHAR_UNIFIED_MAP[variant] = ec;
    }
  }

  // precomputed hashmap for fast precached lookups in .from_short_name
  EMOJICHAR_KEYWORD_MAP = {};

  for (k = 0, len2 = EMOJI_CHARS.length; k < len2; k++) {
    ec = EMOJI_CHARS[k];
    ref1 = ec.short_names;
    for (l = 0, len3 = ref1.length; l < len3; l++) {
      keyword = ref1[l];
      EMOJICHAR_KEYWORD_MAP[keyword] = ec;
    }
  }

  // The RegExp matcher we use to do .scan() efficiently.
  // needs to be defined after self.chars so not at top of file for now...
  FBS_REGEXP = new RegExp(`(?:${EmojiData.chars({
    include_variants: true
  }).join("|")})`, "g");

  return EmojiData;

}).call(this);

module.exports = EmojiData;

module.exports.EmojiChar = EmojiChar;
